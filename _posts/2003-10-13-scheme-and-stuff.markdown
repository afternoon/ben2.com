---
layout: post
title: Scheme and stuff
date: '2003-10-13T15:47:28+01:00'
tags: []
tumblr_url: https://aftnn.org/post/47972972821/scheme-and-stuff
---
<p>Was reading more of <em><a href="http://www.paulgraham.com/onlisp.html">On Lisp</a></em> last night, starting to get into the thick of the language now. I&rsquo;m slightly worried that I&rsquo;m not applying as I&rsquo;m learning. I just can&rsquo;t think of any applications that I want to develop on the console at the moment. In addition to that, all the made up ones are so simple that they don&rsquo;t really provide fertile ground for experimenting with programming techniques.</p>
<p>As I was reading the author mentioned Scheme, which I don&rsquo;t know much about other than that it is Lisp-like in style. I decided to go and find out more and ended up reading an <a href="http://schematics.sourceforge.net/scheme-london/nmk-case-study.pdf">interesting article</a> (PDF) written by some guys at <a href="http://www.lshift.net">LShift</a> about their use of Scheme inside Java on the <a href="http://www.nmk.co.uk/">NMK website</a>.</p>
<p>The site uses an array of off-the-shelf technologies in order to simplify development of the middle tiers. <a href="http://xml.apache.org/cocoon/">Cocoon</a> provides the controller. <a href="http://castor.exolab.org/">Castor</a> creates XML from JavaBeans which is then transformed by XSLT to the output HTML. The JavaBeans are created by business logic routines written in Scheme and interfacing with the outside world using Java-to-Scheme interface in <a href="http://sisc.sourceforge.net/">SISC</a>, a Scheme interpreter written in Java.</p>
<p>The article discusses the relevance of this product-bulky approach and the benefits of using Scheme for the business logic. In a word, continuations. Continuations are, as far as I can tell, a Scheme feature whereby an interpreter can be halted and it&rsquo;s state stored in a closure. Then it can be brought back to life whenever and executed from the same point onwards. This has unique applications in the world of HTTP. What LShift managed to achieve was an abstraction that allows them to invert the control flow of HTTP.</p>
<p>Off the web, programs go about the process of processing and when they need input from the user, they ask for it. With HTTP, this is reversed. The user asks for something and perhaps sends some data in at the same time and the program processes it there and then and returns output as best it can. This can make things confusing when data needs to be gathered over a number of pages or the user starts using their back button etc. LShift hide the fact that the program has to be halted and the user waited on, and indeed that they may never return the required input, by halting the program secretly and then reviving it transparently when required. This allows the flow of a piece of higher level business logic to proceed as if it were a normal console or GUI app.</p>
<p>Which is nice.</p>
