---
layout: post
title: The Haskell Highway
date: '2006-03-22T03:18:38+00:00'
tags: []
tumblr_url: https://aftnn.org/post/47880456985/the-haskell-highway
---
<p>One of my crazy plans for total obscurity (the inverse of world domination) is to try bringing some of the back cover benefits of functional languages to the web frameworks arena, basically to build a <a href="http://www.rubyonrails.com/">Rails</a> or a <a href="http://www.djangoproject.com/">Django</a> in Haskell.</p>
<p>Well, first of all I&rsquo;ve never used Rails, so I suck. So I downloaded it. Haven&rsquo;t done anything with it yet, but just to get it on disk is a big step (I&rsquo;m on the Django devs mailing list for gawd&rsquo;s sake, though only as a lurker). It&rsquo;s all in the name of research guys, honest.</p>
<p>More than anything, this is an exercise in learning a language by applying it to a familiar domain. However, the advantages of implementing such a platform with Haskell are:</p>
<ol>
<li>Non-strict evaluation and compilation provide greater efficiency. Data structure documentation with efficiency comments in big O notation can&rsquo;t hurt either :-).</li>
<li>Expressiveness and clarity of code, Ruby is a touch Perlish, though all the Rails examples are fairly pretty (this is DHH&rsquo;s stated goal for Rails after all). Django isn&rsquo;t quite so pretty perhaps, focusing more on practicality. Python and Ruby have some neat syntactic toys, but Haskell is the state of the art when it comes to expressive code.</li>
<li>Strongly-typed but with type inference. One of the great things about Django (and possibly Rails) and a feature I prized in InfoCMS was beautiful joyous harmony between the types used at the data layer and the types used at the interface layer. Forms are validated using information about the tables the data will have to later be injected into. Lots of very sturdy data types would be fantastically useful for this.</li>
<li>Removal of side effects. Side effects should be limited to the supporting layers that interact with the DB or with the OS etc, my code should be purely functional, allowing clarity and easier debugging and testing.</li>
</ol>
<p>Now, I&rsquo;m reading from the Haskell crib-sheet a bit here, and I haven&rsquo;t necessarily felt the power of these supposed advantages just yet, but it&rsquo;s all interesting theory.</p>
<p>On the other hand, there are some clear disadvantages compared to the way things are done in Django and Python at least, and I suspect Rails and Ruby too.</p>
<ol>
<li>Haskell is a compiled, static language. Django&rsquo;s ORM for example, does all kinds of runtime dynamic magic to provide a slick programmer experience. Though they&rsquo;re removing the more magical magic, introspection is still a big part of the toolset. Particularly in the realm of data models and mapping, it will be hard to provide something as usable under compilation.</li>
<li>No objects, no variables even! My functional skills are not so leet. I&rsquo;ve always been an OO boy. Learning to live without objects and side effects would not be impossible, but it&rsquo;s a <em>huge</em> paradigm shift for me and probably everybody else. Most web hackers want to make their lives easier, and while learning Ruby is a jump many have demonstrated their willingness to make, a whole new language paradigm is a much larger one.</li>
<li>Development speed. The great debate: strong typing, prevents bugs or just slows coders down? Everyone has to unit test anyway, so just catch &lsquo;em there. Now strong typing in Haskell is certainly no where near as much as a drag as in Java or C++ for instance, type inference whilst retaining both parametric and ad hoc polymorphism means a lot. However I&rsquo;m certain that the code-compile-test loop sucks compared to edit-test. The compile step is a big drag on my hacking style, and GHC is not known for it&rsquo;s speediness in compilation. I remember hacking Java for wwWebflow and zoning out completely through compiles, so much so that I&rsquo;d get really lazy and stupid when the time to edit and test came again. This could probably be solved by building a test environment which uses GHCi or Hugs in interactive mode. This would be a must really.</li>
</ol>
<p>Discussion with Ladislav on Hypothetical centered around the problems of implementing the ORM layer without the O bit. Thinking about that now, I think the best way to go would be to allow a developer to specify rules for marshaling Haskell record types into tables (<a href="http://code.djangoproject.com/browser/django/trunk/django/core/db/backends/mysql.py#L174">Django&rsquo;s doing this here</a>). A good set of defaults would be provided, but allowing tweaking of the marshaling rules would allow tenacious DBAs to squeeze maximum performance from the application . Rules would ideally be written in Haskell allowing insertion of custom bits like index magic. Code for pulling records from the DB would be functional, the prevailing model would probably be to write query functions that get used by the controllers. It would be nice to have a Django/Rails/Class::DBI style interface, I just have to think about that some more.</p>
<p>Some of the concerns are deal breakers, but I&rsquo;d love to test them in the wild. Haskell apps have tended to be toys a bit so far, with the notable exception of Darcs. I guess I kind of hope that there&rsquo;s some possibility that a Haskell web framework could garner some interest in the same way. I should just stick to Django probably :-).</p>
<p>I did actually write some actual code on Sunday, for what it&rsquo;s worth. Just some types for representing requests and responses really, all of which is already done in <a href="http://www.mdstud.chalmers.se/~md9ms/hws-wp/">HWS</a>. It felt good though.</p>
